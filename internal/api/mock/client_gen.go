// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock

import (
	"context"

	"github.com/cerebriumai/cerebrium/internal/api"
	mock "github.com/stretchr/testify/mock"
)

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// CancelBuild provides a mock function for the type MockClient
func (_mock *MockClient) CancelBuild(ctx context.Context, projectID string, appName string, buildID string) error {
	ret := _mock.Called(ctx, projectID, appName, buildID)

	if len(ret) == 0 {
		panic("no return value specified for CancelBuild")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, projectID, appName, buildID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_CancelBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelBuild'
type MockClient_CancelBuild_Call struct {
	*mock.Call
}

// CancelBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appName string
//   - buildID string
func (_e *MockClient_Expecter) CancelBuild(ctx interface{}, projectID interface{}, appName interface{}, buildID interface{}) *MockClient_CancelBuild_Call {
	return &MockClient_CancelBuild_Call{Call: _e.mock.On("CancelBuild", ctx, projectID, appName, buildID)}
}

func (_c *MockClient_CancelBuild_Call) Run(run func(ctx context.Context, projectID string, appName string, buildID string)) *MockClient_CancelBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_CancelBuild_Call) Return(err error) *MockClient_CancelBuild_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_CancelBuild_Call) RunAndReturn(run func(ctx context.Context, projectID string, appName string, buildID string) error) *MockClient_CancelBuild_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteUpload provides a mock function for the type MockClient
func (_mock *MockClient) CompleteUpload(ctx context.Context, projectID string, filePath string, uploadID string, region string, parts []api.PartInfo) error {
	ret := _mock.Called(ctx, projectID, filePath, uploadID, region, parts)

	if len(ret) == 0 {
		panic("no return value specified for CompleteUpload")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, []api.PartInfo) error); ok {
		r0 = returnFunc(ctx, projectID, filePath, uploadID, region, parts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_CompleteUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteUpload'
type MockClient_CompleteUpload_Call struct {
	*mock.Call
}

// CompleteUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - filePath string
//   - uploadID string
//   - region string
//   - parts []api.PartInfo
func (_e *MockClient_Expecter) CompleteUpload(ctx interface{}, projectID interface{}, filePath interface{}, uploadID interface{}, region interface{}, parts interface{}) *MockClient_CompleteUpload_Call {
	return &MockClient_CompleteUpload_Call{Call: _e.mock.On("CompleteUpload", ctx, projectID, filePath, uploadID, region, parts)}
}

func (_c *MockClient_CompleteUpload_Call) Run(run func(ctx context.Context, projectID string, filePath string, uploadID string, region string, parts []api.PartInfo)) *MockClient_CompleteUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 []api.PartInfo
		if args[5] != nil {
			arg5 = args[5].([]api.PartInfo)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockClient_CompleteUpload_Call) Return(err error) *MockClient_CompleteUpload_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_CompleteUpload_Call) RunAndReturn(run func(ctx context.Context, projectID string, filePath string, uploadID string, region string, parts []api.PartInfo) error) *MockClient_CompleteUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CreateApp provides a mock function for the type MockClient
func (_mock *MockClient) CreateApp(ctx context.Context, projectID string, payload map[string]any) (*api.CreateAppResponse, error) {
	ret := _mock.Called(ctx, projectID, payload)

	if len(ret) == 0 {
		panic("no return value specified for CreateApp")
	}

	var r0 *api.CreateAppResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, map[string]any) (*api.CreateAppResponse, error)); ok {
		return returnFunc(ctx, projectID, payload)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, map[string]any) *api.CreateAppResponse); ok {
		r0 = returnFunc(ctx, projectID, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateAppResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, map[string]any) error); ok {
		r1 = returnFunc(ctx, projectID, payload)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_CreateApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateApp'
type MockClient_CreateApp_Call struct {
	*mock.Call
}

// CreateApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - payload map[string]any
func (_e *MockClient_Expecter) CreateApp(ctx interface{}, projectID interface{}, payload interface{}) *MockClient_CreateApp_Call {
	return &MockClient_CreateApp_Call{Call: _e.mock.On("CreateApp", ctx, projectID, payload)}
}

func (_c *MockClient_CreateApp_Call) Run(run func(ctx context.Context, projectID string, payload map[string]any)) *MockClient_CreateApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 map[string]any
		if args[2] != nil {
			arg2 = args[2].(map[string]any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_CreateApp_Call) Return(createAppResponse *api.CreateAppResponse, err error) *MockClient_CreateApp_Call {
	_c.Call.Return(createAppResponse, err)
	return _c
}

func (_c *MockClient_CreateApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, payload map[string]any) (*api.CreateAppResponse, error)) *MockClient_CreateApp_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBaseImage provides a mock function for the type MockClient
func (_mock *MockClient) CreateBaseImage(ctx context.Context, projectID string, region string, dependencies map[string]any) (string, error) {
	ret := _mock.Called(ctx, projectID, region, dependencies)

	if len(ret) == 0 {
		panic("no return value specified for CreateBaseImage")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, map[string]any) (string, error)); ok {
		return returnFunc(ctx, projectID, region, dependencies)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, map[string]any) string); ok {
		r0 = returnFunc(ctx, projectID, region, dependencies)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, map[string]any) error); ok {
		r1 = returnFunc(ctx, projectID, region, dependencies)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_CreateBaseImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBaseImage'
type MockClient_CreateBaseImage_Call struct {
	*mock.Call
}

// CreateBaseImage is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - region string
//   - dependencies map[string]any
func (_e *MockClient_Expecter) CreateBaseImage(ctx interface{}, projectID interface{}, region interface{}, dependencies interface{}) *MockClient_CreateBaseImage_Call {
	return &MockClient_CreateBaseImage_Call{Call: _e.mock.On("CreateBaseImage", ctx, projectID, region, dependencies)}
}

func (_c *MockClient_CreateBaseImage_Call) Run(run func(ctx context.Context, projectID string, region string, dependencies map[string]any)) *MockClient_CreateBaseImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 map[string]any
		if args[3] != nil {
			arg3 = args[3].(map[string]any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_CreateBaseImage_Call) Return(s string, err error) *MockClient_CreateBaseImage_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockClient_CreateBaseImage_Call) RunAndReturn(run func(ctx context.Context, projectID string, region string, dependencies map[string]any) (string, error)) *MockClient_CreateBaseImage_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRunApp provides a mock function for the type MockClient
func (_mock *MockClient) CreateRunApp(ctx context.Context, projectID string, appID string, region string) error {
	ret := _mock.Called(ctx, projectID, appID, region)

	if len(ret) == 0 {
		panic("no return value specified for CreateRunApp")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, projectID, appID, region)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_CreateRunApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRunApp'
type MockClient_CreateRunApp_Call struct {
	*mock.Call
}

// CreateRunApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - region string
func (_e *MockClient_Expecter) CreateRunApp(ctx interface{}, projectID interface{}, appID interface{}, region interface{}) *MockClient_CreateRunApp_Call {
	return &MockClient_CreateRunApp_Call{Call: _e.mock.On("CreateRunApp", ctx, projectID, appID, region)}
}

func (_c *MockClient_CreateRunApp_Call) Run(run func(ctx context.Context, projectID string, appID string, region string)) *MockClient_CreateRunApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_CreateRunApp_Call) Return(err error) *MockClient_CreateRunApp_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_CreateRunApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, region string) error) *MockClient_CreateRunApp_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteApp provides a mock function for the type MockClient
func (_mock *MockClient) DeleteApp(ctx context.Context, projectID string, appID string) error {
	ret := _mock.Called(ctx, projectID, appID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApp")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, projectID, appID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_DeleteApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteApp'
type MockClient_DeleteApp_Call struct {
	*mock.Call
}

// DeleteApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
func (_e *MockClient_Expecter) DeleteApp(ctx interface{}, projectID interface{}, appID interface{}) *MockClient_DeleteApp_Call {
	return &MockClient_DeleteApp_Call{Call: _e.mock.On("DeleteApp", ctx, projectID, appID)}
}

func (_c *MockClient_DeleteApp_Call) Run(run func(ctx context.Context, projectID string, appID string)) *MockClient_DeleteApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_DeleteApp_Call) Return(err error) *MockClient_DeleteApp_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_DeleteApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string) error) *MockClient_DeleteApp_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFile provides a mock function for the type MockClient
func (_mock *MockClient) DeleteFile(ctx context.Context, projectID string, filePath string, region string) error {
	ret := _mock.Called(ctx, projectID, filePath, region)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, projectID, filePath, region)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type MockClient_DeleteFile_Call struct {
	*mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - filePath string
//   - region string
func (_e *MockClient_Expecter) DeleteFile(ctx interface{}, projectID interface{}, filePath interface{}, region interface{}) *MockClient_DeleteFile_Call {
	return &MockClient_DeleteFile_Call{Call: _e.mock.On("DeleteFile", ctx, projectID, filePath, region)}
}

func (_c *MockClient_DeleteFile_Call) Run(run func(ctx context.Context, projectID string, filePath string, region string)) *MockClient_DeleteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_DeleteFile_Call) Return(err error) *MockClient_DeleteFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_DeleteFile_Call) RunAndReturn(run func(ctx context.Context, projectID string, filePath string, region string) error) *MockClient_DeleteFile_Call {
	_c.Call.Return(run)
	return _c
}

// FetchAppLogs provides a mock function for the type MockClient
func (_mock *MockClient) FetchAppLogs(ctx context.Context, projectID string, appID string, opts api.AppLogOptions) (*api.AppLogsResponse, error) {
	ret := _mock.Called(ctx, projectID, appID, opts)

	if len(ret) == 0 {
		panic("no return value specified for FetchAppLogs")
	}

	var r0 *api.AppLogsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, api.AppLogOptions) (*api.AppLogsResponse, error)); ok {
		return returnFunc(ctx, projectID, appID, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, api.AppLogOptions) *api.AppLogsResponse); ok {
		r0 = returnFunc(ctx, projectID, appID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AppLogsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, api.AppLogOptions) error); ok {
		r1 = returnFunc(ctx, projectID, appID, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_FetchAppLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchAppLogs'
type MockClient_FetchAppLogs_Call struct {
	*mock.Call
}

// FetchAppLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - opts api.AppLogOptions
func (_e *MockClient_Expecter) FetchAppLogs(ctx interface{}, projectID interface{}, appID interface{}, opts interface{}) *MockClient_FetchAppLogs_Call {
	return &MockClient_FetchAppLogs_Call{Call: _e.mock.On("FetchAppLogs", ctx, projectID, appID, opts)}
}

func (_c *MockClient_FetchAppLogs_Call) Run(run func(ctx context.Context, projectID string, appID string, opts api.AppLogOptions)) *MockClient_FetchAppLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 api.AppLogOptions
		if args[3] != nil {
			arg3 = args[3].(api.AppLogOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_FetchAppLogs_Call) Return(appLogsResponse *api.AppLogsResponse, err error) *MockClient_FetchAppLogs_Call {
	_c.Call.Return(appLogsResponse, err)
	return _c
}

func (_c *MockClient_FetchAppLogs_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, opts api.AppLogOptions) (*api.AppLogsResponse, error)) *MockClient_FetchAppLogs_Call {
	_c.Call.Return(run)
	return _c
}

// FetchBuildLogs provides a mock function for the type MockClient
func (_mock *MockClient) FetchBuildLogs(ctx context.Context, projectID string, appName string, buildID string) (*api.BuildLogsResponse, error) {
	ret := _mock.Called(ctx, projectID, appName, buildID)

	if len(ret) == 0 {
		panic("no return value specified for FetchBuildLogs")
	}

	var r0 *api.BuildLogsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*api.BuildLogsResponse, error)); ok {
		return returnFunc(ctx, projectID, appName, buildID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *api.BuildLogsResponse); ok {
		r0 = returnFunc(ctx, projectID, appName, buildID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BuildLogsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, appName, buildID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_FetchBuildLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchBuildLogs'
type MockClient_FetchBuildLogs_Call struct {
	*mock.Call
}

// FetchBuildLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appName string
//   - buildID string
func (_e *MockClient_Expecter) FetchBuildLogs(ctx interface{}, projectID interface{}, appName interface{}, buildID interface{}) *MockClient_FetchBuildLogs_Call {
	return &MockClient_FetchBuildLogs_Call{Call: _e.mock.On("FetchBuildLogs", ctx, projectID, appName, buildID)}
}

func (_c *MockClient_FetchBuildLogs_Call) Run(run func(ctx context.Context, projectID string, appName string, buildID string)) *MockClient_FetchBuildLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_FetchBuildLogs_Call) Return(buildLogsResponse *api.BuildLogsResponse, err error) *MockClient_FetchBuildLogs_Call {
	_c.Call.Return(buildLogsResponse, err)
	return _c
}

func (_c *MockClient_FetchBuildLogs_Call) RunAndReturn(run func(ctx context.Context, projectID string, appName string, buildID string) (*api.BuildLogsResponse, error)) *MockClient_FetchBuildLogs_Call {
	_c.Call.Return(run)
	return _c
}

// FetchNotifications provides a mock function for the type MockClient
func (_mock *MockClient) FetchNotifications(ctx context.Context) ([]api.Notification, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FetchNotifications")
	}

	var r0 []api.Notification
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]api.Notification, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []api.Notification); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Notification)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_FetchNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchNotifications'
type MockClient_FetchNotifications_Call struct {
	*mock.Call
}

// FetchNotifications is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) FetchNotifications(ctx interface{}) *MockClient_FetchNotifications_Call {
	return &MockClient_FetchNotifications_Call{Call: _e.mock.On("FetchNotifications", ctx)}
}

func (_c *MockClient_FetchNotifications_Call) Run(run func(ctx context.Context)) *MockClient_FetchNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockClient_FetchNotifications_Call) Return(notifications []api.Notification, err error) *MockClient_FetchNotifications_Call {
	_c.Call.Return(notifications, err)
	return _c
}

func (_c *MockClient_FetchNotifications_Call) RunAndReturn(run func(ctx context.Context) ([]api.Notification, error)) *MockClient_FetchNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// FetchRunLogs provides a mock function for the type MockClient
func (_mock *MockClient) FetchRunLogs(ctx context.Context, projectID string, appName string, runID string, nextToken string) (*api.RunLogsResponse, error) {
	ret := _mock.Called(ctx, projectID, appName, runID, nextToken)

	if len(ret) == 0 {
		panic("no return value specified for FetchRunLogs")
	}

	var r0 *api.RunLogsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (*api.RunLogsResponse, error)); ok {
		return returnFunc(ctx, projectID, appName, runID, nextToken)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) *api.RunLogsResponse); ok {
		r0 = returnFunc(ctx, projectID, appName, runID, nextToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RunLogsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, appName, runID, nextToken)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_FetchRunLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchRunLogs'
type MockClient_FetchRunLogs_Call struct {
	*mock.Call
}

// FetchRunLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appName string
//   - runID string
//   - nextToken string
func (_e *MockClient_Expecter) FetchRunLogs(ctx interface{}, projectID interface{}, appName interface{}, runID interface{}, nextToken interface{}) *MockClient_FetchRunLogs_Call {
	return &MockClient_FetchRunLogs_Call{Call: _e.mock.On("FetchRunLogs", ctx, projectID, appName, runID, nextToken)}
}

func (_c *MockClient_FetchRunLogs_Call) Run(run func(ctx context.Context, projectID string, appName string, runID string, nextToken string)) *MockClient_FetchRunLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockClient_FetchRunLogs_Call) Return(runLogsResponse *api.RunLogsResponse, err error) *MockClient_FetchRunLogs_Call {
	_c.Call.Return(runLogsResponse, err)
	return _c
}

func (_c *MockClient_FetchRunLogs_Call) RunAndReturn(run func(ctx context.Context, projectID string, appName string, runID string, nextToken string) (*api.RunLogsResponse, error)) *MockClient_FetchRunLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetApp provides a mock function for the type MockClient
func (_mock *MockClient) GetApp(ctx context.Context, projectID string, appID string) (*api.AppDetails, error) {
	ret := _mock.Called(ctx, projectID, appID)

	if len(ret) == 0 {
		panic("no return value specified for GetApp")
	}

	var r0 *api.AppDetails
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*api.AppDetails, error)); ok {
		return returnFunc(ctx, projectID, appID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *api.AppDetails); ok {
		r0 = returnFunc(ctx, projectID, appID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AppDetails)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, appID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApp'
type MockClient_GetApp_Call struct {
	*mock.Call
}

// GetApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
func (_e *MockClient_Expecter) GetApp(ctx interface{}, projectID interface{}, appID interface{}) *MockClient_GetApp_Call {
	return &MockClient_GetApp_Call{Call: _e.mock.On("GetApp", ctx, projectID, appID)}
}

func (_c *MockClient_GetApp_Call) Run(run func(ctx context.Context, projectID string, appID string)) *MockClient_GetApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_GetApp_Call) Return(appDetails *api.AppDetails, err error) *MockClient_GetApp_Call {
	_c.Call.Return(appDetails, err)
	return _c
}

func (_c *MockClient_GetApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string) (*api.AppDetails, error)) *MockClient_GetApp_Call {
	_c.Call.Return(run)
	return _c
}

// GetApps provides a mock function for the type MockClient
func (_mock *MockClient) GetApps(ctx context.Context, projectID string) ([]api.App, error) {
	ret := _mock.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetApps")
	}

	var r0 []api.App
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]api.App, error)); ok {
		return returnFunc(ctx, projectID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []api.App); ok {
		r0 = returnFunc(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.App)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetApps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApps'
type MockClient_GetApps_Call struct {
	*mock.Call
}

// GetApps is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockClient_Expecter) GetApps(ctx interface{}, projectID interface{}) *MockClient_GetApps_Call {
	return &MockClient_GetApps_Call{Call: _e.mock.On("GetApps", ctx, projectID)}
}

func (_c *MockClient_GetApps_Call) Run(run func(ctx context.Context, projectID string)) *MockClient_GetApps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockClient_GetApps_Call) Return(apps []api.App, err error) *MockClient_GetApps_Call {
	_c.Call.Return(apps, err)
	return _c
}

func (_c *MockClient_GetApps_Call) RunAndReturn(run func(ctx context.Context, projectID string) ([]api.App, error)) *MockClient_GetApps_Call {
	_c.Call.Return(run)
	return _c
}

// GetBuild provides a mock function for the type MockClient
func (_mock *MockClient) GetBuild(ctx context.Context, projectID string, appID string, buildID string) (*api.AppBuild, error) {
	ret := _mock.Called(ctx, projectID, appID, buildID)

	if len(ret) == 0 {
		panic("no return value specified for GetBuild")
	}

	var r0 *api.AppBuild
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*api.AppBuild, error)); ok {
		return returnFunc(ctx, projectID, appID, buildID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *api.AppBuild); ok {
		r0 = returnFunc(ctx, projectID, appID, buildID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.AppBuild)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, appID, buildID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBuild'
type MockClient_GetBuild_Call struct {
	*mock.Call
}

// GetBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - buildID string
func (_e *MockClient_Expecter) GetBuild(ctx interface{}, projectID interface{}, appID interface{}, buildID interface{}) *MockClient_GetBuild_Call {
	return &MockClient_GetBuild_Call{Call: _e.mock.On("GetBuild", ctx, projectID, appID, buildID)}
}

func (_c *MockClient_GetBuild_Call) Run(run func(ctx context.Context, projectID string, appID string, buildID string)) *MockClient_GetBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_GetBuild_Call) Return(appBuild *api.AppBuild, err error) *MockClient_GetBuild_Call {
	_c.Call.Return(appBuild, err)
	return _c
}

func (_c *MockClient_GetBuild_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, buildID string) (*api.AppBuild, error)) *MockClient_GetBuild_Call {
	_c.Call.Return(run)
	return _c
}

// GetDownloadURL provides a mock function for the type MockClient
func (_mock *MockClient) GetDownloadURL(ctx context.Context, projectID string, filePath string, region string) (string, error) {
	ret := _mock.Called(ctx, projectID, filePath, region)

	if len(ret) == 0 {
		panic("no return value specified for GetDownloadURL")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return returnFunc(ctx, projectID, filePath, region)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = returnFunc(ctx, projectID, filePath, region)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, filePath, region)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetDownloadURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDownloadURL'
type MockClient_GetDownloadURL_Call struct {
	*mock.Call
}

// GetDownloadURL is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - filePath string
//   - region string
func (_e *MockClient_Expecter) GetDownloadURL(ctx interface{}, projectID interface{}, filePath interface{}, region interface{}) *MockClient_GetDownloadURL_Call {
	return &MockClient_GetDownloadURL_Call{Call: _e.mock.On("GetDownloadURL", ctx, projectID, filePath, region)}
}

func (_c *MockClient_GetDownloadURL_Call) Run(run func(ctx context.Context, projectID string, filePath string, region string)) *MockClient_GetDownloadURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_GetDownloadURL_Call) Return(s string, err error) *MockClient_GetDownloadURL_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockClient_GetDownloadURL_Call) RunAndReturn(run func(ctx context.Context, projectID string, filePath string, region string) (string, error)) *MockClient_GetDownloadURL_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjects provides a mock function for the type MockClient
func (_mock *MockClient) GetProjects(ctx context.Context) ([]api.Project, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetProjects")
	}

	var r0 []api.Project
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]api.Project, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []api.Project); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Project)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjects'
type MockClient_GetProjects_Call struct {
	*mock.Call
}

// GetProjects is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockClient_Expecter) GetProjects(ctx interface{}) *MockClient_GetProjects_Call {
	return &MockClient_GetProjects_Call{Call: _e.mock.On("GetProjects", ctx)}
}

func (_c *MockClient_GetProjects_Call) Run(run func(ctx context.Context)) *MockClient_GetProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockClient_GetProjects_Call) Return(projects []api.Project, err error) *MockClient_GetProjects_Call {
	_c.Call.Return(projects, err)
	return _c
}

func (_c *MockClient_GetProjects_Call) RunAndReturn(run func(ctx context.Context) ([]api.Project, error)) *MockClient_GetProjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunStatus provides a mock function for the type MockClient
func (_mock *MockClient) GetRunStatus(ctx context.Context, projectID string, appName string, runID string) (*api.RunStatus, error) {
	ret := _mock.Called(ctx, projectID, appName, runID)

	if len(ret) == 0 {
		panic("no return value specified for GetRunStatus")
	}

	var r0 *api.RunStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*api.RunStatus, error)); ok {
		return returnFunc(ctx, projectID, appName, runID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *api.RunStatus); ok {
		r0 = returnFunc(ctx, projectID, appName, runID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RunStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, appName, runID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetRunStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunStatus'
type MockClient_GetRunStatus_Call struct {
	*mock.Call
}

// GetRunStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appName string
//   - runID string
func (_e *MockClient_Expecter) GetRunStatus(ctx interface{}, projectID interface{}, appName interface{}, runID interface{}) *MockClient_GetRunStatus_Call {
	return &MockClient_GetRunStatus_Call{Call: _e.mock.On("GetRunStatus", ctx, projectID, appName, runID)}
}

func (_c *MockClient_GetRunStatus_Call) Run(run func(ctx context.Context, projectID string, appName string, runID string)) *MockClient_GetRunStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_GetRunStatus_Call) Return(runStatus *api.RunStatus, err error) *MockClient_GetRunStatus_Call {
	_c.Call.Return(runStatus, err)
	return _c
}

func (_c *MockClient_GetRunStatus_Call) RunAndReturn(run func(ctx context.Context, projectID string, appName string, runID string) (*api.RunStatus, error)) *MockClient_GetRunStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetRuns provides a mock function for the type MockClient
func (_mock *MockClient) GetRuns(ctx context.Context, projectID string, appID string, asyncOnly bool) ([]api.Run, error) {
	ret := _mock.Called(ctx, projectID, appID, asyncOnly)

	if len(ret) == 0 {
		panic("no return value specified for GetRuns")
	}

	var r0 []api.Run
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, bool) ([]api.Run, error)); ok {
		return returnFunc(ctx, projectID, appID, asyncOnly)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, bool) []api.Run); ok {
		r0 = returnFunc(ctx, projectID, appID, asyncOnly)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Run)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = returnFunc(ctx, projectID, appID, asyncOnly)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRuns'
type MockClient_GetRuns_Call struct {
	*mock.Call
}

// GetRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - asyncOnly bool
func (_e *MockClient_Expecter) GetRuns(ctx interface{}, projectID interface{}, appID interface{}, asyncOnly interface{}) *MockClient_GetRuns_Call {
	return &MockClient_GetRuns_Call{Call: _e.mock.On("GetRuns", ctx, projectID, appID, asyncOnly)}
}

func (_c *MockClient_GetRuns_Call) Run(run func(ctx context.Context, projectID string, appID string, asyncOnly bool)) *MockClient_GetRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bool
		if args[3] != nil {
			arg3 = args[3].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_GetRuns_Call) Return(runs []api.Run, err error) *MockClient_GetRuns_Call {
	_c.Call.Return(runs, err)
	return _c
}

func (_c *MockClient_GetRuns_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, asyncOnly bool) ([]api.Run, error)) *MockClient_GetRuns_Call {
	_c.Call.Return(run)
	return _c
}

// InitiateUpload provides a mock function for the type MockClient
func (_mock *MockClient) InitiateUpload(ctx context.Context, projectID string, filePath string, region string, partCount int) (*api.InitiateUploadResponse, error) {
	ret := _mock.Called(ctx, projectID, filePath, region, partCount)

	if len(ret) == 0 {
		panic("no return value specified for InitiateUpload")
	}

	var r0 *api.InitiateUploadResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, int) (*api.InitiateUploadResponse, error)); ok {
		return returnFunc(ctx, projectID, filePath, region, partCount)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, int) *api.InitiateUploadResponse); ok {
		r0 = returnFunc(ctx, projectID, filePath, region, partCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InitiateUploadResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, int) error); ok {
		r1 = returnFunc(ctx, projectID, filePath, region, partCount)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_InitiateUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitiateUpload'
type MockClient_InitiateUpload_Call struct {
	*mock.Call
}

// InitiateUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - filePath string
//   - region string
//   - partCount int
func (_e *MockClient_Expecter) InitiateUpload(ctx interface{}, projectID interface{}, filePath interface{}, region interface{}, partCount interface{}) *MockClient_InitiateUpload_Call {
	return &MockClient_InitiateUpload_Call{Call: _e.mock.On("InitiateUpload", ctx, projectID, filePath, region, partCount)}
}

func (_c *MockClient_InitiateUpload_Call) Run(run func(ctx context.Context, projectID string, filePath string, region string, partCount int)) *MockClient_InitiateUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockClient_InitiateUpload_Call) Return(initiateUploadResponse *api.InitiateUploadResponse, err error) *MockClient_InitiateUpload_Call {
	_c.Call.Return(initiateUploadResponse, err)
	return _c
}

func (_c *MockClient_InitiateUpload_Call) RunAndReturn(run func(ctx context.Context, projectID string, filePath string, region string, partCount int) (*api.InitiateUploadResponse, error)) *MockClient_InitiateUpload_Call {
	_c.Call.Return(run)
	return _c
}

// ListFiles provides a mock function for the type MockClient
func (_mock *MockClient) ListFiles(ctx context.Context, projectID string, path string, region string) ([]api.FileInfo, error) {
	ret := _mock.Called(ctx, projectID, path, region)

	if len(ret) == 0 {
		panic("no return value specified for ListFiles")
	}

	var r0 []api.FileInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) ([]api.FileInfo, error)); ok {
		return returnFunc(ctx, projectID, path, region)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) []api.FileInfo); ok {
		r0 = returnFunc(ctx, projectID, path, region)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.FileInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, projectID, path, region)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFiles'
type MockClient_ListFiles_Call struct {
	*mock.Call
}

// ListFiles is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - path string
//   - region string
func (_e *MockClient_Expecter) ListFiles(ctx interface{}, projectID interface{}, path interface{}, region interface{}) *MockClient_ListFiles_Call {
	return &MockClient_ListFiles_Call{Call: _e.mock.On("ListFiles", ctx, projectID, path, region)}
}

func (_c *MockClient_ListFiles_Call) Run(run func(ctx context.Context, projectID string, path string, region string)) *MockClient_ListFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_ListFiles_Call) Return(fileInfos []api.FileInfo, err error) *MockClient_ListFiles_Call {
	_c.Call.Return(fileInfos, err)
	return _c
}

func (_c *MockClient_ListFiles_Call) RunAndReturn(run func(ctx context.Context, projectID string, path string, region string) ([]api.FileInfo, error)) *MockClient_ListFiles_Call {
	_c.Call.Return(run)
	return _c
}

// RunApp provides a mock function for the type MockClient
func (_mock *MockClient) RunApp(ctx context.Context, projectID string, appID string, region string, filename string, functionName *string, imageDigest *string, hardwareConfig map[string]any, tarPath string, data map[string]any) (*api.RunResponse, error) {
	ret := _mock.Called(ctx, projectID, appID, region, filename, functionName, imageDigest, hardwareConfig, tarPath, data)

	if len(ret) == 0 {
		panic("no return value specified for RunApp")
	}

	var r0 *api.RunResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, *string, *string, map[string]any, string, map[string]any) (*api.RunResponse, error)); ok {
		return returnFunc(ctx, projectID, appID, region, filename, functionName, imageDigest, hardwareConfig, tarPath, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, *string, *string, map[string]any, string, map[string]any) *api.RunResponse); ok {
		r0 = returnFunc(ctx, projectID, appID, region, filename, functionName, imageDigest, hardwareConfig, tarPath, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.RunResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string, *string, *string, map[string]any, string, map[string]any) error); ok {
		r1 = returnFunc(ctx, projectID, appID, region, filename, functionName, imageDigest, hardwareConfig, tarPath, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_RunApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunApp'
type MockClient_RunApp_Call struct {
	*mock.Call
}

// RunApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - region string
//   - filename string
//   - functionName *string
//   - imageDigest *string
//   - hardwareConfig map[string]any
//   - tarPath string
//   - data map[string]any
func (_e *MockClient_Expecter) RunApp(ctx interface{}, projectID interface{}, appID interface{}, region interface{}, filename interface{}, functionName interface{}, imageDigest interface{}, hardwareConfig interface{}, tarPath interface{}, data interface{}) *MockClient_RunApp_Call {
	return &MockClient_RunApp_Call{Call: _e.mock.On("RunApp", ctx, projectID, appID, region, filename, functionName, imageDigest, hardwareConfig, tarPath, data)}
}

func (_c *MockClient_RunApp_Call) Run(run func(ctx context.Context, projectID string, appID string, region string, filename string, functionName *string, imageDigest *string, hardwareConfig map[string]any, tarPath string, data map[string]any)) *MockClient_RunApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 *string
		if args[5] != nil {
			arg5 = args[5].(*string)
		}
		var arg6 *string
		if args[6] != nil {
			arg6 = args[6].(*string)
		}
		var arg7 map[string]any
		if args[7] != nil {
			arg7 = args[7].(map[string]any)
		}
		var arg8 string
		if args[8] != nil {
			arg8 = args[8].(string)
		}
		var arg9 map[string]any
		if args[9] != nil {
			arg9 = args[9].(map[string]any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
			arg9,
		)
	})
	return _c
}

func (_c *MockClient_RunApp_Call) Return(runResponse *api.RunResponse, err error) *MockClient_RunApp_Call {
	_c.Call.Return(runResponse, err)
	return _c
}

func (_c *MockClient_RunApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, region string, filename string, functionName *string, imageDigest *string, hardwareConfig map[string]any, tarPath string, data map[string]any) (*api.RunResponse, error)) *MockClient_RunApp_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateApp provides a mock function for the type MockClient
func (_mock *MockClient) UpdateApp(ctx context.Context, projectID string, appID string, updates map[string]any) error {
	ret := _mock.Called(ctx, projectID, appID, updates)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApp")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, map[string]any) error); ok {
		r0 = returnFunc(ctx, projectID, appID, updates)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_UpdateApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateApp'
type MockClient_UpdateApp_Call struct {
	*mock.Call
}

// UpdateApp is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - appID string
//   - updates map[string]any
func (_e *MockClient_Expecter) UpdateApp(ctx interface{}, projectID interface{}, appID interface{}, updates interface{}) *MockClient_UpdateApp_Call {
	return &MockClient_UpdateApp_Call{Call: _e.mock.On("UpdateApp", ctx, projectID, appID, updates)}
}

func (_c *MockClient_UpdateApp_Call) Run(run func(ctx context.Context, projectID string, appID string, updates map[string]any)) *MockClient_UpdateApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 map[string]any
		if args[3] != nil {
			arg3 = args[3].(map[string]any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockClient_UpdateApp_Call) Return(err error) *MockClient_UpdateApp_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_UpdateApp_Call) RunAndReturn(run func(ctx context.Context, projectID string, appID string, updates map[string]any) error) *MockClient_UpdateApp_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPart provides a mock function for the type MockClient
func (_mock *MockClient) UploadPart(ctx context.Context, url string, data []byte) (string, error) {
	ret := _mock.Called(ctx, url, data)

	if len(ret) == 0 {
		panic("no return value specified for UploadPart")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) (string, error)); ok {
		return returnFunc(ctx, url, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte) string); ok {
		r0 = returnFunc(ctx, url, data)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []byte) error); ok {
		r1 = returnFunc(ctx, url, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_UploadPart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPart'
type MockClient_UploadPart_Call struct {
	*mock.Call
}

// UploadPart is a helper method to define mock.On call
//   - ctx context.Context
//   - url string
//   - data []byte
func (_e *MockClient_Expecter) UploadPart(ctx interface{}, url interface{}, data interface{}) *MockClient_UploadPart_Call {
	return &MockClient_UploadPart_Call{Call: _e.mock.On("UploadPart", ctx, url, data)}
}

func (_c *MockClient_UploadPart_Call) Run(run func(ctx context.Context, url string, data []byte)) *MockClient_UploadPart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_UploadPart_Call) Return(s string, err error) *MockClient_UploadPart_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockClient_UploadPart_Call) RunAndReturn(run func(ctx context.Context, url string, data []byte) (string, error)) *MockClient_UploadPart_Call {
	_c.Call.Return(run)
	return _c
}

// UploadZip provides a mock function for the type MockClient
func (_mock *MockClient) UploadZip(ctx context.Context, uploadURL string, zipPath string) error {
	ret := _mock.Called(ctx, uploadURL, zipPath)

	if len(ret) == 0 {
		panic("no return value specified for UploadZip")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, uploadURL, zipPath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockClient_UploadZip_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadZip'
type MockClient_UploadZip_Call struct {
	*mock.Call
}

// UploadZip is a helper method to define mock.On call
//   - ctx context.Context
//   - uploadURL string
//   - zipPath string
func (_e *MockClient_Expecter) UploadZip(ctx interface{}, uploadURL interface{}, zipPath interface{}) *MockClient_UploadZip_Call {
	return &MockClient_UploadZip_Call{Call: _e.mock.On("UploadZip", ctx, uploadURL, zipPath)}
}

func (_c *MockClient_UploadZip_Call) Run(run func(ctx context.Context, uploadURL string, zipPath string)) *MockClient_UploadZip_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClient_UploadZip_Call) Return(err error) *MockClient_UploadZip_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockClient_UploadZip_Call) RunAndReturn(run func(ctx context.Context, uploadURL string, zipPath string) error) *MockClient_UploadZip_Call {
	_c.Call.Return(run)
	return _c
}
